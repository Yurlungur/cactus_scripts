#!/usr/bin/env python2

"""
plot_robust_stability_at_time.py
Author: Jonah Miller (jonah.maxwell.miller@gmail.com)
Time-stamp: <2014-03-13 11:11:43 (jonah)>

This is a program that plots the (x,y)-component of the 3-metric at a
given time of a spacetime generated by the robust stability test. This
spacetime should be Minkowski space, where g_{xy} should be zero. So
we can think of this term as the error.

We project along the x-axis.

Example call:
python2 plot_robust_stability_at_time.py time *.asc

where time is the time you want to plot at. Make sure that a snapshot
exists at this time for all spacetimes you want to plot. Otherwise the

program will raise an error.
"""

# Imports
# ----------------------------------------------------------------------
import extract_tensor_data as etd # To deal with tensor ascii files
import numpy as np # for array support
import sys # Command line IO
# plot tools
import matplotlib as mpl
import matplotlib.pyplot as plt
# ----------------------------------------------------------------------


# Global constants
# ----------------------------------------------------------------------
COORD = 0 # The x coordinate
T_INDEX=(0,1) # The component of the metric tensor
LINEWIDTH = 5
FONTSIZE = 20
XLABEL = "Position"
YLABEL = r'$g_{xy}$'
TITLE = "Robust Stability Test\nAt a Fixed Time T={}"
# ----------------------------------------------------------------------


def get_Txy_data(time,filename_list):
    """
    Takes a list of filenames (strings) and generates three lists,
    positions_list, Txy_list, time_index_list. positions_list contains
    positions data as described in extract_tensor_data.py. Txy_list
    contains data the xy-element of the symmetric tensor we wish to
    investigate for each file.

    time_index_list defines the time iteration at which the data is
    extracted.

    Also returns lattice spacing, which is the spacing between
    points. We call the lattice spacing h. Returns a list, h for every
    file.
    """
    positions_list = []
    Txy_list = []
    time_index_list = []
    h_list = []
    for filename in filename_list:
        data = etd.extract_data(filename)
        times = [snapshot[0][4] for snapshot in data]
        # time_index = etd.find_largest_index_of_subvalue(times,time)
        time_index = times.index(time) # Raises error if times are not exact
        position,Txy=etd.element_of_position_at_time(T_INDEX[0], T_INDEX[1],
                                                     COORD, time_index, data)
        time_index_list.append(time_index)
        positions_list.append(position)
        Txy_list.append(Txy)
        h_list.append(etd.get_lattice_spacing(data))
    return positions_list,Txy_list,time_index_list,h_list

def plot_Txy(positions_list,Txy_list,name_list,time):
    """
    Plots the theoretical value for Txy, the xy-component of the
    tensor we're interested in at the time (not time index) and
    compares it to the same plots stored in positions_list and
    Txy_list. Uses the name_list for a legend.
    """
    # Find the plot domain
    xmin = min([min(position) for position in positions_list])
    xmax = max([max(position) for position in positions_list])

    # Change font size
    mpl.rcParams.update({'font.size': FONTSIZE})
    # Define plots
    lines = [plt.plot(positions_list[i],Txy_list[i],linewidth=LINEWIDTH) \
                 for i in range(len(positions_list))]

    # Plot parameters
    plt.xlim([xmin,xmax])
    plt.xlabel(XLABEL)
    plt.ylabel(YLABEL)
    plt.title(TITLE.format(time))
    plt.legend(name_list)
    plt.show()
    return


def main(time,filename_list):
    """
    Plots gxy for every file in the file list at the given time.
    """
    positions_list,gxy_list,time_list,h_list = get_Txy_data(time,
                                                            filename_list)
    plot_Txy(positions_list,gxy_list,filename_list,time)
    return


if __name__ == "__main__":
    time = float(sys.argv[1])
    file_list = sys.argv[2:]
    main(time,file_list)

    
