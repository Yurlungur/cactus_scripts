"""
plog_gaugewave_norm2_error.py
Author: Jonah Miller (jonah.maxwell.miller@gmail.com)
Time-stamp: <2014-03-13 19:51:27 (jonah)>

This is a little library to plot the norm2 of the error due to a gauge
wave. It's equivalent to plot_gaugewave_multipatch.py and extends it.
"""

# Imports
# ----------------------------------------------------------------------
# Import the standard tools
import numpy as np # Array support
import os # For operating system support
import math
from collections import namedtuple
# Plot tools
import matplotlib as mpl
import matplotlib.pyplot as plt
# Import other pieces of the toolbox
import extract_tensor_data_multipatch as multipatch # For tensor
import simfactory_interface as interface # for simfactory support
import plot_gaugewave_multipatch as pgm
import plot_gaugewave as pg
import find_times
# ----------------------------------------------------------------------

# Global Constants
# ----------------------------------------------------------------------
# Whether or not we want to do a log plot on the y axis
XLABEL = 'Time'
YLABEL = r'$\|$' + 'error(' + r'$g_{xx}$' + ')' + r'$h\|_2$'
TITLE = "Gauge Wave Norm Error as a Function of Time"
CONVERGENCE_TITLE="Gauge Wave Convergence Order As a Function of Time"
CONVERGENCE_YLABEL="log"+r'$_{(h2/h1)}(\|e_2\|_2/\|e_1\|_2)$'
LINEWIDTH=pg.my_linewidth
FONTSIZE=pg.fontsize
SEMILOGY = False
EXPONENT = pg.EXPONENT
# A data structure
SimData = namedtuple('SimData',['snapshots','h','num_cells','shared_indices'])
# ----------------------------------------------------------------------

def get_data(directory_list,file_name=False):
    """
    Takes a list of directories and outputs a list of SimData objects,
    each for a different simulation. Each object contains:

    Snapshots: a list list of data similar to the data extracted by
    extract_tensor_data. It's of the form:
    [snapshot1,snapshot2,snapshot3,...]  where each snapshot is of the
    form
    [time,positions,elements]
    where time is a scalar and positions and elements is the data
    required to plot the xx-component of the metric tensor at a given
    time.

    h is the grid spacing
    num_cells is the number of cells

    Also returns shared times, a list of all the times shared by each element.

    Shared indexes is a dictionary for each simulation mapping shared
    times to the iteration index associated with them.
    """
    simulations = [None]*len(directory_list)
    shared_times = find_times.get_time_intersections_from_directories(directory_list)
    shared_times = [float('%.10f' % time) for time in shared_times]
    for i in range(len(directory_list)):
        directory = directory_list[i]
        tensor_data,coordinate_maps,h,num_cells = pgm.generate_map_resolution_and_tensor_data(directory,pgm.RESTART_NUMBER,file_name)
        snapshots_list = []
        shared_indices = {}
        for time_index in range(len(tensor_data)):
            time = float('%.10f' % tensor_data[time_index][0][-3])
            if time in shared_times:
                shared_indices[time] = time_index
            positions,elements = multipatch.element_of_position_at_time(pgm.E_INDEX[0],pgm.E_INDEX[1],pgm.COORD,time_index,tensor_data,coordinate_maps)
            snapshots_list.append([time,positions,elements])
        simulations[i] = SimData(snapshots_list,h,num_cells,shared_indices)
    simulations.sort(key=lambda simulation: simulation.num_cells)
    return simulations,shared_times

def make_norm2_error(function,positions,elements,time,h):
    """
    Given a function for the analytic solution and the grid spacing
    and positions and elements for a given moment in time, generates
    the norm2 error defined as ||e||_2, where

    (||e||_2)^2 = \sum_{j=1}^n |e_j|^2 h

    where

    e = data - analytic_solution
    """
    errors = pg.get_error(function,positions,elements,time)
    norm2_error = np.sqrt(sum([(e**2)*h for e in errors]))
    return norm2_error

def plot_norm2_error_of_time(function,simulations_list,plot_semilogy=False):
    """
    Given a list of simulation data objects extracted by get_data, and
    the analytic solution, plots the norm2 error of every simulation
    as a function of time. The legend is generated by the number of
    cells

    y axis is on a log scale if plot_semilogy is set to True
    """
    plot = plt.semilogy if plot_semilogy else plt.plot
    name_list = ["{} Cells".format(simulation.num_cells)\
                     for simulation in simulations_list]
    norm2_errors = [[make_norm2_error(function,snapshot[1],snapshot[2],snapshot[0],simulation.h)*(simulation.h)**EXPONENT for snapshot in simulation.snapshots] for simulation in simulations_list]
    times = [[snapshot[0] for snapshot in simulation.snapshots] for simulation in simulations_list]
    # Define the plot 
    mpl.rcParams.update({'font.size':FONTSIZE})
    lines = [plot(times[i],norm2_errors[i],linewidth=LINEWIDTH) \
                 for i in range(len(norm2_errors))]
    plt.title(TITLE)
    plt.xlabel(XLABEL)
    plt.ylabel(YLABEL)
    plt.legend(name_list)
    plt.show()
    return

def plot_self_convergence_factor(function,simulations_list,shared_times):
    """
    The order of convergence for a method will be approximately

    n = log_(h2/h1)(|e_2|_2/|e_1|_2)

    This method calculates this.
    """
    title = CONVERGENCE_TITLE
    ylabel = CONVERGENCE_YLABEL
    # Define y axis
    orders_list = [[None]*len(shared_times)\
                       for i in range(len(simulations_list)-1)]
    print shared_times
    for i in range(len(simulations_list)-1):
        sim1 = simulations_list[i]
        sim2 = simulations_list[i+1]
        base = sim1.h/sim2.h
        for j in range(len(shared_times)):
            index1 = sim1.shared_indices[shared_times[j]]
            index2 = sim2.shared_indices[shared_times[j]]
            numerator = make_norm2_error(function,
                                       sim1.snapshots[index1][1],
                                       sim1.snapshots[index1][2],
                                       sim1.snapshots[index1][0],
                                       sim1.h)
            denominator = make_norm2_error(function,
                                           sim2.snapshots[index2][1],
                                           sim2.snapshots[index2][2],
                                           sim2.snapshots[index2][0],
                                           sim2.h)
            orders_list[i][j] = math.log(numerator/denominator,base)
    # Define the legend
    line_names = ["{} Cells Vs. {} Cells".format(simulations_list[i].num_cells,simulations_list[i+1].num_cells) for i in range(len(simulations_list)-1)]
    # Define the plot
    mpl.rcParams.update({'font.size':FONTSIZE})
    lines = [plt.plot(shared_times,orders,linewidth=LINEWIDTH) for orders in orders_list]
    plt.title(title)
    plt.xlabel(XLABEL)
    plt.ylabel(ylabel)
    plt.legend(line_names,loc=4)
    plt.show()
    return        

def main(function,arguments,plot_semilogy):
    """
    Given an analytic function, command line arguments (i.e.,
    sys.argv, and instructions on the y scale, plots the norm2 error
    as a function of time.
    """
    directory_list = arguments[1:]
    simulations_list,shared_times = get_data(directory_list)
    plot_norm2_error_of_time(function,simulations_list,plot_semilogy)
    plot_self_convergence_factor(function,simulations_list,shared_times)
    return

if __name__ == "__main__":
    raise ImportWarning(multipatch.WARNING_MESSAGE)
